import { Response } from 'express';
import prisma from '../config/database';
import { AuthRequest } from '../middleware/auth';
import logger from '../utils/logger';
import { validationResult } from 'express-validator';
import * as fs from 'fs/promises';
import * as path from 'path';
import { exec } from 'child_process';
import { promisify } from 'util';
import { CRS_RULES } from '../config/crs-rules';

const execAsync = promisify(exec);

const MODSEC_CUSTOM_RULES_PATH = '/etc/nginx/modsec/custom_rules';
const MODSEC_CRS_DISABLE_PATH = '/etc/nginx/modsec/crs_disabled';
const MODSEC_CRS_DISABLE_FILE = '/etc/nginx/modsec/crs_disabled.conf';

/**
 * Extract actual rule IDs from CRS rule file
 */
async function extractRuleIdsFromCRSFile(ruleFile: string): Promise<number[]> {
  try {
    const crsFilePath = path.join('/etc/nginx/modsec/coreruleset/rules', ruleFile);
    const content = await fs.readFile(crsFilePath, 'utf-8');
    
    // Extract all "id:XXXXX" patterns
    const idMatches = content.matchAll(/id:(\d+)/g);
    const ids = new Set<number>();
    
    for (const match of idMatches) {
      ids.add(parseInt(match[1]));
    }
    
    return Array.from(ids).sort((a, b) => a - b);
  } catch (error: any) {
    logger.warn(`Failed to extract rule IDs from ${ruleFile}: ${error.message}`);
    return [];
  }
}

/**
 * Regenerate CRS disable configuration file from database
 */
async function regenerateCRSDisableConfig(domainId?: string): Promise<void> {
  try {
    // Get all disabled CRS rules from database
    const disabledRules = await prisma.modSecCRSRule.findMany({
      where: {
        domainId: domainId || null,
        enabled: false,
      },
    });

    // Build disable content
    let disableContent = '# CRS Disabled Rules\n';
    disableContent += '# Auto-generated by Nginx Love UI - DO NOT EDIT MANUALLY\n';
    disableContent += `# Generated at: ${new Date().toISOString()}\n\n`;

    if (disabledRules.length === 0) {
      disableContent += '# No disabled rules\n';
    } else {
      for (const rule of disabledRules) {
        const crsRule = CRS_RULES.find(r => r.ruleFile === rule.ruleFile);
        if (!crsRule) continue;

        disableContent += `# Disable: ${crsRule.name} (${crsRule.category})\n`;
        disableContent += `# File: ${crsRule.ruleFile}\n`;
        
        // Extract actual rule IDs from CRS file
        const ruleIds = await extractRuleIdsFromCRSFile(crsRule.ruleFile);
        
        if (ruleIds.length === 0) {
          disableContent += `# Warning: No rule IDs found in ${crsRule.ruleFile}\n`;
        } else {
          disableContent += `# Found ${ruleIds.length} rules to disable\n`;
          
          // Remove rules by actual IDs
          for (const id of ruleIds) {
            disableContent += `SecRuleRemoveById ${id}\n`;
          }
        }
        disableContent += '\n';
      }
    }

    // Write to single disable file
    await fs.writeFile(MODSEC_CRS_DISABLE_FILE, disableContent, 'utf-8');
    logger.info(`Regenerated CRS disable config: ${disabledRules.length} rule file(s) disabled`);
  } catch (error) {
    logger.error('Failed to regenerate CRS disable config:', error);
    throw error;
  }
}

/**
 * Generate CRS disable configuration file (DEPRECATED - use regenerateCRSDisableConfig)
 */
async function generateCRSDisableConfig(ruleFile: string, enabled: boolean): Promise<void> {
  // This function is deprecated, now we regenerate the entire file
  logger.warn('generateCRSDisableConfig is deprecated, using regenerateCRSDisableConfig instead');
  await regenerateCRSDisableConfig();
}

/**
 * Auto reload nginx with smart retry logic
 * @param silent - If true, don't throw errors, just log them
 */
async function autoReloadNginx(silent: boolean = false): Promise<boolean> {
  try {
    // Test nginx configuration first
    try {
      await execAsync('nginx -t');
    } catch (error: any) {
      logger.error('Nginx configuration test failed:', error.stderr);
      if (!silent) throw new Error(`Nginx config test failed: ${error.stderr}`);
      return false;
    }

    // Try graceful reload first
    try {
      logger.info('Auto-reloading nginx (graceful)...');
      await execAsync('systemctl reload nginx');
      
      // Wait for reload to take effect
      await new Promise(resolve => setTimeout(resolve, 500));
      
      // Verify nginx is active
      const { stdout } = await execAsync('systemctl is-active nginx');
      if (stdout.trim() === 'active') {
        logger.info('Nginx auto-reloaded successfully');
        return true;
      }
    } catch (error: any) {
      logger.warn('Graceful reload failed, trying restart...', error.message);
    }

    // Fallback to restart
    logger.info('Auto-restarting nginx...');
    await execAsync('systemctl restart nginx');
    
    // Wait for restart
    await new Promise(resolve => setTimeout(resolve, 1000));
    
    // Verify nginx started
    const { stdout } = await execAsync('systemctl is-active nginx');
    if (stdout.trim() !== 'active') {
      throw new Error('Nginx not active after restart');
    }
    
    logger.info('Nginx auto-restarted successfully');
    return true;
  } catch (error: any) {
    logger.error('Auto reload nginx failed:', error);
    if (!silent) throw error;
    return false;
  }
}

/**
 * Get all CRS (OWASP Core Rule Set) rules
 */
export const getCRSRules = async (req: AuthRequest, res: Response): Promise<void> => {
  try {
    const { domainId } = req.query;

    // Get enabled status from database
    const dbRules = await prisma.modSecCRSRule.findMany({
      where: domainId ? { domainId: domainId as string } : { domainId: null },
      orderBy: { category: 'asc' },
    });

    // Map CRS_RULES with DB status
    const rules = CRS_RULES.map(crsRule => {
      const dbRule = dbRules.find(r => r.ruleFile === crsRule.ruleFile);
      return {
        id: dbRule?.id,
        ruleFile: crsRule.ruleFile,
        name: crsRule.name,
        category: crsRule.category,
        description: crsRule.description,
        enabled: dbRule?.enabled ?? true, // Default enabled
        paranoia: crsRule.paranoia,
        createdAt: dbRule?.createdAt,
        updatedAt: dbRule?.updatedAt,
      };
    });

    res.json({
      success: true,
      data: rules,
    });
  } catch (error) {
    logger.error('Get CRS rules error:', error);
    res.status(500).json({
      success: false,
      message: 'Internal server error',
    });
  }
};

/**
 * Toggle CRS rule status
 */
export const toggleCRSRule = async (req: AuthRequest, res: Response): Promise<void> => {
  try {
    const { ruleFile } = req.params;
    const { domainId } = req.body;

    // Check if rule file exists in CRS_RULES
    const crsRule = CRS_RULES.find(r => r.ruleFile === ruleFile);
    if (!crsRule) {
      res.status(404).json({
        success: false,
        message: 'CRS rule not found',
      });
      return;
    }

    // Get current status or create new
    const existingRule = await prisma.modSecCRSRule.findFirst({
      where: {
        ruleFile,
        domainId: domainId || null,
      },
    });

    let updatedRule;
    if (existingRule) {
      // Toggle existing
      updatedRule = await prisma.modSecCRSRule.update({
        where: { id: existingRule.id },
        data: { enabled: !existingRule.enabled },
      });
    } else {
      // Create new (disabled by default since we're toggling)
      updatedRule = await prisma.modSecCRSRule.create({
        data: {
          ruleFile: crsRule.ruleFile,
          name: crsRule.name,
          category: crsRule.category,
          description: crsRule.description,
          enabled: false,
          paranoia: crsRule.paranoia || 1,
          domainId: domainId || null,
        },
      });
    }

    logger.info(`CRS rule ${crsRule.name} ${updatedRule.enabled ? 'enabled' : 'disabled'}`, {
      ruleFile,
      userId: req.user?.userId,
    });

    // Regenerate CRS disable configuration file
    await regenerateCRSDisableConfig(domainId);

    // Auto reload nginx
    await autoReloadNginx(true);

    res.json({
      success: true,
      message: `Rule ${updatedRule.enabled ? 'enabled' : 'disabled'} successfully`,
      data: updatedRule,
    });
  } catch (error) {
    logger.error('Toggle CRS rule error:', error);
    res.status(500).json({
      success: false,
      message: 'Internal server error',
    });
  }
};

/**
 * Get all ModSecurity custom rules
 */
export const getModSecRules = async (req: AuthRequest, res: Response): Promise<void> => {
  try {
    const { domainId } = req.query;

    let rules;
    if (domainId) {
      // Get rules for specific domain
      rules = await prisma.modSecRule.findMany({
        where: { domainId: domainId as string },
        orderBy: { category: 'asc' },
      });
    } else {
      // Get global rules (no domain association)
      rules = await prisma.modSecRule.findMany({
        where: { domainId: null },
        orderBy: { category: 'asc' },
      });
    }

    res.json({
      success: true,
      data: rules,
    });
  } catch (error) {
    logger.error('Get ModSec rules error:', error);
    res.status(500).json({
      success: false,
      message: 'Internal server error',
    });
  }
};

/**
 * Get single ModSecurity rule by ID
 */
export const getModSecRule = async (req: AuthRequest, res: Response): Promise<void> => {
  try {
    const { id } = req.params;

    const rule = await prisma.modSecRule.findUnique({
      where: { id },
      include: {
        domain: {
          select: {
            id: true,
            name: true,
          },
        },
      },
    });

    if (!rule) {
      res.status(404).json({
        success: false,
        message: 'ModSecurity rule not found',
      });
      return;
    }

    res.json({
      success: true,
      data: rule,
    });
  } catch (error) {
    logger.error('Get ModSec rule error:', error);
    res.status(500).json({
      success: false,
      message: 'Internal server error',
    });
  }
};

/**
 * Toggle ModSecurity rule status
 */
export const toggleModSecRule = async (req: AuthRequest, res: Response): Promise<void> => {
  try {
    const { id } = req.params;

    const rule = await prisma.modSecRule.findUnique({
      where: { id },
    });

    if (!rule) {
      res.status(404).json({
        success: false,
        message: 'ModSecurity rule not found',
      });
      return;
    }

    const updatedRule = await prisma.modSecRule.update({
      where: { id },
      data: { enabled: !rule.enabled },
    });

    logger.info(`ModSecurity rule ${updatedRule.name} ${updatedRule.enabled ? 'enabled' : 'disabled'}`, {
      ruleId: id,
      userId: req.user?.userId,
    });

    // Auto reload nginx
    await autoReloadNginx(true);

    res.json({
      success: true,
      message: `Rule ${updatedRule.enabled ? 'enabled' : 'disabled'} successfully`,
      data: updatedRule,
    });
  } catch (error) {
    logger.error('Toggle ModSec rule error:', error);
    res.status(500).json({
      success: false,
      message: 'Internal server error',
    });
  }
};

/**
 * Add custom ModSecurity rule
 */
export const addCustomRule = async (req: AuthRequest, res: Response): Promise<void> => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      res.status(400).json({
        success: false,
        errors: errors.array(),
      });
      return;
    }

    const { name, category, ruleContent, description, domainId, enabled = true } = req.body;

    // Validate domain if specified
    if (domainId) {
      const domain = await prisma.domain.findUnique({
        where: { id: domainId },
      });

      if (!domain) {
        res.status(404).json({
          success: false,
          message: 'Domain not found',
        });
        return;
      }
    }

    // Create rule in database
    const rule = await prisma.modSecRule.create({
      data: {
        name,
        category,
        ruleContent,
        description,
        domainId: domainId || null,
        enabled,
      },
    });

    // Write rule to file if enabled
    if (enabled) {
      try {
        // Ensure custom rules directory exists
        await fs.mkdir(MODSEC_CUSTOM_RULES_PATH, { recursive: true });

        const ruleFileName = `custom_${rule.id}.conf`;
        const ruleFilePath = path.join(MODSEC_CUSTOM_RULES_PATH, ruleFileName);

        await fs.writeFile(ruleFilePath, ruleContent, 'utf-8');
        logger.info(`Custom ModSecurity rule file created: ${ruleFilePath}`);

        // Auto reload nginx
        await autoReloadNginx(true);
      } catch (error: any) {
        logger.error('Failed to write custom rule file:', error);
        // Continue even if file write fails
      }
    }

    logger.info(`Custom ModSecurity rule added: ${rule.name}`, {
      ruleId: rule.id,
      userId: req.user?.userId,
    });

    res.status(201).json({
      success: true,
      message: 'Custom rule added successfully',
      data: rule,
    });
  } catch (error) {
    logger.error('Add custom rule error:', error);
    res.status(500).json({
      success: false,
      message: 'Internal server error',
    });
  }
};

/**
 * Update ModSecurity rule
 */
export const updateModSecRule = async (req: AuthRequest, res: Response): Promise<void> => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      res.status(400).json({
        success: false,
        errors: errors.array(),
      });
      return;
    }

    const { id } = req.params;
    const { name, category, ruleContent, description, enabled } = req.body;

    const rule = await prisma.modSecRule.findUnique({
      where: { id },
    });

    if (!rule) {
      res.status(404).json({
        success: false,
        message: 'ModSecurity rule not found',
      });
      return;
    }

    const updatedRule = await prisma.modSecRule.update({
      where: { id },
      data: {
        ...(name && { name }),
        ...(category && { category }),
        ...(ruleContent && { ruleContent }),
        ...(description !== undefined && { description }),
        ...(enabled !== undefined && { enabled }),
      },
    });

    // Update rule file if exists
    const ruleFileName = `custom_${rule.id}.conf`;
    const ruleFilePath = path.join(MODSEC_CUSTOM_RULES_PATH, ruleFileName);

    try {
      await fs.access(ruleFilePath);
      
      if (updatedRule.enabled && ruleContent) {
        await fs.writeFile(ruleFilePath, ruleContent, 'utf-8');
        logger.info(`Custom ModSecurity rule file updated: ${ruleFilePath}`);
      } else if (!updatedRule.enabled) {
        await fs.unlink(ruleFilePath);
        logger.info(`Custom ModSecurity rule file removed: ${ruleFilePath}`);
      }

      // Auto reload nginx
      await autoReloadNginx(true);
    } catch (error: any) {
      // File doesn't exist or error accessing it
      if (updatedRule.enabled && ruleContent) {
        await fs.mkdir(MODSEC_CUSTOM_RULES_PATH, { recursive: true });
        await fs.writeFile(ruleFilePath, ruleContent, 'utf-8');
        await autoReloadNginx(true);
      }
    }

    logger.info(`ModSecurity rule updated: ${updatedRule.name}`, {
      ruleId: id,
      userId: req.user?.userId,
    });

    res.json({
      success: true,
      message: 'Rule updated successfully',
      data: updatedRule,
    });
  } catch (error) {
    logger.error('Update ModSec rule error:', error);
    res.status(500).json({
      success: false,
      message: 'Internal server error',
    });
  }
};

/**
 * Delete ModSecurity rule
 */
export const deleteModSecRule = async (req: AuthRequest, res: Response): Promise<void> => {
  try {
    const { id } = req.params;

    const rule = await prisma.modSecRule.findUnique({
      where: { id },
    });

    if (!rule) {
      res.status(404).json({
        success: false,
        message: 'ModSecurity rule not found',
      });
      return;
    }

    await prisma.modSecRule.delete({
      where: { id },
    });

    // Delete rule file if exists
    const ruleFileName = `custom_${rule.id}.conf`;
    const ruleFilePath = path.join(MODSEC_CUSTOM_RULES_PATH, ruleFileName);

    try {
      await fs.unlink(ruleFilePath);
      logger.info(`Custom ModSecurity rule file deleted: ${ruleFilePath}`);

      // Auto reload nginx
      await autoReloadNginx(true);
    } catch (error: any) {
      // File doesn't exist, continue
    }

    logger.info(`ModSecurity rule deleted: ${rule.name}`, {
      ruleId: id,
      userId: req.user?.userId,
    });

    res.json({
      success: true,
      message: 'Rule deleted successfully',
    });
  } catch (error) {
    logger.error('Delete ModSec rule error:', error);
    res.status(500).json({
      success: false,
      message: 'Internal server error',
    });
  }
};

/**
 * Get global ModSecurity settings
 */
export const getGlobalModSecSettings = async (req: AuthRequest, res: Response): Promise<void> => {
  try {
    // Check if ModSecurity main config exists
    const config = await prisma.nginxConfig.findFirst({
      where: {
        configType: 'modsecurity',
        name: 'global_settings',
      },
    });

    const enabled = config?.enabled ?? true;

    res.json({
      success: true,
      data: {
        enabled,
        config: config || null,
      },
    });
  } catch (error) {
    logger.error('Get global ModSec settings error:', error);
    res.status(500).json({
      success: false,
      message: 'Internal server error',
    });
  }
};

/**
 * Set global ModSecurity enabled/disabled
 */
export const setGlobalModSec = async (req: AuthRequest, res: Response): Promise<void> => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      res.status(400).json({
        success: false,
        errors: errors.array(),
      });
      return;
    }

    const { enabled } = req.body;

    // Find existing global ModSecurity config
    let config = await prisma.nginxConfig.findFirst({
      where: {
        configType: 'modsecurity',
        name: 'global_settings',
      },
    });

    if (config) {
      // Update existing config
      config = await prisma.nginxConfig.update({
        where: { id: config.id },
        data: { enabled },
      });
    } else {
      // Create new config
      config = await prisma.nginxConfig.create({
        data: {
          configType: 'modsecurity',
          name: 'global_settings',
          content: `# ModSecurity Global Settings\nSecRuleEngine ${enabled ? 'On' : 'Off'}`,
          enabled,
        },
      });
    }

    logger.info(`Global ModSecurity ${enabled ? 'enabled' : 'disabled'}`, {
      userId: req.user?.userId,
    });

    // Auto reload nginx
    await autoReloadNginx(true);

    res.json({
      success: true,
      message: `ModSecurity globally ${enabled ? 'enabled' : 'disabled'}`,
      data: config,
    });
  } catch (error) {
    logger.error('Set global ModSec error:', error);
    res.status(500).json({
      success: false,
      message: 'Internal server error',
    });
  }
};
