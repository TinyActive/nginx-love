import * as fs from 'fs/promises';
import * as path from 'path';
import { exec } from 'child_process';
import { promisify } from 'util';
import logger from '../../utils/logger';
import { modSecRepository } from './modsec.repository';
import { crsRulesService } from './services/crs-rules.service';
import { modSecSetupService } from './services/modsec-setup.service';
import { AddCustomRuleDto, UpdateModSecRuleDto, ToggleCRSRuleDto, SetGlobalModSecDto } from './dto';
import { CRSRule, ModSecRule, ModSecRuleWithDomain, GlobalModSecSettings, NginxReloadResult } from './modsec.types';

const execAsync = promisify(exec);

const MODSEC_CUSTOM_RULES_PATH = '/etc/nginx/modsec/custom_rules';
const MODSEC_CRS_DISABLE_FILE = '/etc/nginx/modsec/crs_disabled.conf';

/**
 * ModSecurity service
 * Handles all business logic for ModSecurity rules management
 */
export class ModSecService {
  /**
   * Extract actual rule IDs from CRS rule file
   */
  private async extractRuleIdsFromCRSFile(ruleFile: string): Promise<number[]> {
    try {
      const crsFilePath = path.join('/etc/nginx/modsec/coreruleset/rules', ruleFile);
      const content = await fs.readFile(crsFilePath, 'utf-8');

      // Extract all "id:XXXXX" patterns
      const idMatches = content.matchAll(/id:(\d+)/g);
      const ids = new Set<number>();

      for (const match of idMatches) {
        ids.add(parseInt(match[1]));
      }

      return Array.from(ids).sort((a, b) => a - b);
    } catch (error: any) {
      logger.warn(`Failed to extract rule IDs from ${ruleFile}: ${error.message}`);
      return [];
    }
  }

  /**
   * Extract rule IDs from custom rule content
   */
  private extractRuleIdsFromContent(ruleContent: string): number[] {
    const idMatches = ruleContent.matchAll(/id:(\d+)/g);
    const ids = new Set<number>();

    for (const match of idMatches) {
      ids.add(parseInt(match[1]));
    }

    return Array.from(ids).sort((a, b) => a - b);
  }

  /**
   * Get all existing rule IDs from custom rules
   */
  private async getAllExistingRuleIds(excludeRuleId?: string): Promise<Set<number>> {
    const allRuleIds = new Set<number>();
    
    try {
      // Get all custom rules from database
      const customRules = await modSecRepository.findModSecRules();
      
      for (const rule of customRules) {
        // Skip the rule being updated
        if (excludeRuleId && rule.id === excludeRuleId) {
          continue;
        }
        
        // Extract IDs from rule content
        const ruleIds = this.extractRuleIdsFromContent(rule.ruleContent);
        ruleIds.forEach(id => allRuleIds.add(id));
      }
    } catch (error: any) {
      logger.error('Failed to get existing rule IDs:', error);
    }
    
    return allRuleIds;
  }

  /**
   * Validate rule IDs for duplicates
   */
  private async validateRuleIds(ruleContent: string, excludeRuleId?: string): Promise<{ valid: boolean; duplicateIds: number[] }> {
    const newRuleIds = this.extractRuleIdsFromContent(ruleContent);
    
    if (newRuleIds.length === 0) {
      return { valid: true, duplicateIds: [] };
    }
    
    const existingRuleIds = await this.getAllExistingRuleIds(excludeRuleId);
    const duplicateIds: number[] = [];
    
    for (const id of newRuleIds) {
      if (existingRuleIds.has(id)) {
        duplicateIds.push(id);
      }
    }
    
    return {
      valid: duplicateIds.length === 0,
      duplicateIds,
    };
  }

  /**
   * Test nginx configuration validity
   */
  private async testNginxConfig(): Promise<{ valid: boolean; error?: string }> {
    try {
      await execAsync('nginx -t 2>&1');
      return { valid: true };
    } catch (error: any) {
      const errorMessage = error.stderr || error.stdout || error.message;
      logger.error('Nginx configuration test failed:', errorMessage);
      return { valid: false, error: errorMessage };
    }
  }

  /**
   * Regenerate CRS disable configuration file from database
   */
  private async regenerateCRSDisableConfig(domainId?: string): Promise<void> {
    try {
      // Get all disabled CRS rules from database
      const disabledRules = await modSecRepository.findCRSRules(domainId);
      const disabledOnly = disabledRules.filter(rule => !rule.enabled);

      // Build disable content
      let disableContent = '# CRS Disabled Rules\n';
      disableContent += '# Auto-generated by Nginx Love UI - DO NOT EDIT MANUALLY\n';
      disableContent += `# Generated at: ${new Date().toISOString()}\n\n`;

      if (disabledOnly.length === 0) {
        disableContent += '# No disabled rules\n';
      } else {
        for (const rule of disabledOnly) {
          const crsRule = crsRulesService.getRuleByFile(rule.ruleFile);
          if (!crsRule) continue;

          disableContent += `# Disable: ${crsRule.name} (${crsRule.category})\n`;
          disableContent += `# File: ${crsRule.ruleFile}\n`;

          // Extract actual rule IDs from CRS file
          const ruleIds = await this.extractRuleIdsFromCRSFile(crsRule.ruleFile);

          if (ruleIds.length === 0) {
            disableContent += `# Warning: No rule IDs found in ${crsRule.ruleFile}\n`;
          } else {
            disableContent += `# Found ${ruleIds.length} rules to disable\n`;

            // Remove rules by actual IDs
            for (const id of ruleIds) {
              disableContent += `SecRuleRemoveById ${id}\n`;
            }
          }
          disableContent += '\n';
        }
      }

      // Write to single disable file
      await fs.writeFile(MODSEC_CRS_DISABLE_FILE, disableContent, 'utf-8');
      logger.info(`Regenerated CRS disable config: ${disabledOnly.length} rule file(s) disabled`);
    } catch (error) {
      logger.error('Failed to regenerate CRS disable config:', error);
      throw error;
    }
  }

  /**
   * Auto reload nginx with smart retry logic
   */
  private async autoReloadNginx(silent: boolean = false): Promise<NginxReloadResult> {
    try {
      // Test nginx configuration first
      try {
        await execAsync('nginx -t');
      } catch (error: any) {
        logger.error('Nginx configuration test failed:', error.stderr);
        if (!silent) throw new Error(`Nginx config test failed: ${error.stderr}`);
        return { success: false, message: `Nginx config test failed: ${error.stderr}` };
      }

      // Try graceful reload first
      try {
        logger.info('Auto-reloading nginx (graceful)...');
        await execAsync('nginx -s reload');

        // Wait for reload to take effect
        await new Promise(resolve => setTimeout(resolve, 2000));

        // Verify nginx is active
        const { stdout } = await execAsync("pgrep nginx > /dev/null && echo 'active' || echo 'inactive'");
        if (stdout.trim() === 'active') {
          logger.info('Nginx auto-reloaded successfully');
          return { success: true };
        }
      } catch (error: any) {
        logger.warn('Graceful reload failed, trying restart...', error.message);
      }

      // Fallback to restart
      logger.info('Auto-restarting nginx...');
      await execAsync('nginx -s stop || true && rm -f /var/run/nginx.pid && nginx');

      // Wait for restart
      await new Promise(resolve => setTimeout(resolve, 1000));

      // Verify nginx started
      const { stdout } = await execAsync("pgrep nginx > /dev/null && echo 'active' || echo 'inactive'");
      if (stdout.trim() !== 'active') {
        throw new Error('Nginx not active after restart');
      }

      logger.info('Nginx auto-restarted successfully');
      return { success: true };
    } catch (error: any) {
      logger.error('Auto reload nginx failed:', error);
      if (!silent) throw error;
      return { success: false, message: error.message };
    }
  }

  /**
   * CRS Rules operations
   */

  async getCRSRules(domainId?: string): Promise<CRSRule[]> {
    // Get enabled status from database
    const dbRules = await modSecRepository.findCRSRules(domainId);

    // Map CRS_RULES with DB status
    const allCRSRules = crsRulesService.getAllRules();
    const rules = allCRSRules.map(crsRule => {
      const dbRule = dbRules.find(r => r.ruleFile === crsRule.ruleFile);
      return {
        id: dbRule?.id,
        ruleFile: crsRule.ruleFile,
        name: crsRule.name,
        category: crsRule.category,
        description: crsRule.description,
        enabled: dbRule?.enabled ?? true, // Default enabled
        paranoia: crsRule.paranoia || 1,
        createdAt: dbRule?.createdAt,
        updatedAt: dbRule?.updatedAt,
      };
    });

    return rules;
  }

  async toggleCRSRule(ruleFile: string, dto: ToggleCRSRuleDto): Promise<CRSRule> {
    const { domainId } = dto;

    // Check if rule file exists in CRS_RULES
    const crsRule = crsRulesService.getRuleByFile(ruleFile);
    if (!crsRule) {
      throw new Error('CRS rule not found');
    }

    // Get current status or create new
    const existingRule = await modSecRepository.findCRSRuleByFile(ruleFile, domainId);

    let updatedRule;
    if (existingRule) {
      // Toggle existing
      updatedRule = await modSecRepository.updateCRSRule(existingRule.id, !existingRule.enabled);
    } else {
      // Create new (disabled by default since we're toggling)
      updatedRule = await modSecRepository.createCRSRule({
        ruleFile: crsRule.ruleFile,
        name: crsRule.name,
        category: crsRule.category,
        description: crsRule.description,
        enabled: false,
        paranoia: crsRule.paranoia || 1,
        domainId: domainId || null,
      });
    }

    logger.info(`CRS rule ${crsRule.name} ${updatedRule.enabled ? 'enabled' : 'disabled'}`, {
      ruleFile,
    });

    // Regenerate CRS disable configuration file
    await this.regenerateCRSDisableConfig(domainId);

    // Auto reload nginx
    await this.autoReloadNginx(true);

    return {
      id: updatedRule.id ?? undefined,
      ruleFile: updatedRule.ruleFile,
      name: updatedRule.name,
      category: updatedRule.category,
      description: updatedRule.description,
      enabled: updatedRule.enabled,
      paranoia: updatedRule.paranoia,
      createdAt: updatedRule.createdAt,
      updatedAt: updatedRule.updatedAt,
    };
  }

  /**
   * Custom ModSec Rules operations
   */

  async getModSecRules(domainId?: string): Promise<ModSecRule[]> {
    return modSecRepository.findModSecRules(domainId);
  }

  async getModSecRule(id: string): Promise<ModSecRuleWithDomain> {
    const rule = await modSecRepository.findModSecRuleById(id);
    if (!rule) {
      throw new Error('ModSecurity rule not found');
    }
    return rule;
  }

  async toggleModSecRule(id: string): Promise<ModSecRule> {
    const rule = await modSecRepository.findModSecRuleById(id);
    if (!rule) {
      throw new Error('ModSecurity rule not found');
    }

    const updatedRule = await modSecRepository.toggleModSecRule(id, !rule.enabled);

    // Handle file renaming based on enabled status
    const enabledFileName = `custom_${rule.id}.conf`;
    const disabledFileName = `custom_${rule.id}.conf.disabled`;
    const enabledFilePath = path.join(MODSEC_CUSTOM_RULES_PATH, enabledFileName);
    const disabledFilePath = path.join(MODSEC_CUSTOM_RULES_PATH, disabledFileName);

    try {
      if (updatedRule.enabled) {
        // Enable: rename .disabled to .conf
        try {
          await fs.access(disabledFilePath);
          await fs.rename(disabledFilePath, enabledFilePath);
          logger.info(`Renamed rule file to enabled: ${enabledFileName}`);
        } catch (error) {
          // File might not exist or already enabled, that's ok
          logger.warn(`Could not find disabled file to enable: ${disabledFileName}`);
        }
      } else {
        // Disable: rename .conf to .conf.disabled
        try {
          await fs.access(enabledFilePath);
          await fs.rename(enabledFilePath, disabledFilePath);
          logger.info(`Renamed rule file to disabled: ${disabledFileName}`);
        } catch (error) {
          // File might not exist or already disabled, that's ok
          logger.warn(`Could not find enabled file to disable: ${enabledFileName}`);
        }
      }

      // Auto reload nginx
      await this.autoReloadNginx(true);
    } catch (error: any) {
      logger.error('Failed to rename rule file:', error);
      // Continue even if file rename fails
    }

    logger.info(`ModSecurity rule ${updatedRule.name} ${updatedRule.enabled ? 'enabled' : 'disabled'}`, {
      ruleId: id,
    });

    return updatedRule;
  }

  async addCustomRule(dto: AddCustomRuleDto): Promise<ModSecRule> {
    // Validate domain if specified
    if (dto.domainId) {
      const domain = await modSecRepository.findDomainById(dto.domainId);
      if (!domain) {
        throw new Error('Domain not found');
      }
    }

    // Validate rule IDs for duplicates
    const ruleIdValidation = await this.validateRuleIds(dto.ruleContent);
    if (!ruleIdValidation.valid) {
      throw new Error(`Rule ID(s) already exist: ${ruleIdValidation.duplicateIds.join(', ')}. Please use unique rule IDs.`);
    }

    // Create rule in database first
    const rule = await modSecRepository.createModSecRule(dto);

    // Write rule to file (with appropriate extension based on enabled status)
    let ruleFilePath: string | null = null;
    try {
      // Ensure custom rules directory exists
      await fs.mkdir(MODSEC_CUSTOM_RULES_PATH, { recursive: true });

      const ruleFileName = rule.enabled 
        ? `custom_${rule.id}.conf` 
        : `custom_${rule.id}.conf.disabled`;
      ruleFilePath = path.join(MODSEC_CUSTOM_RULES_PATH, ruleFileName);

      await fs.writeFile(ruleFilePath, dto.ruleContent, 'utf-8');
      logger.info(`Custom ModSecurity rule file created: ${ruleFilePath}`);

      // Test nginx configuration if rule is enabled
      if (rule.enabled) {
        const configTest = await this.testNginxConfig();
        if (!configTest.valid) {
          // Rollback: delete the file and database entry
          try {
            await fs.unlink(ruleFilePath);
            await modSecRepository.deleteModSecRule(rule.id);
          } catch (rollbackError) {
            logger.error('Failed to rollback after nginx config test failure:', rollbackError);
          }
          throw new Error(`Nginx configuration test failed: ${configTest.error}`);
        }

        // Reload nginx if config is valid
        const reloadResult = await this.autoReloadNginx(false);
        if (!reloadResult.success) {
          // Rollback: delete the file and database entry
          try {
            await fs.unlink(ruleFilePath);
            await modSecRepository.deleteModSecRule(rule.id);
          } catch (rollbackError) {
            logger.error('Failed to rollback after nginx reload failure:', rollbackError);
          }
          throw new Error(`Nginx reload failed: ${reloadResult.message}`);
        }
      }
    } catch (error: any) {
      logger.error('Failed to write custom rule file:', error);
      // If it's our validation error, rethrow it
      if (error.message.includes('Nginx configuration test failed') || error.message.includes('Nginx reload failed')) {
        throw error;
      }
      // For other errors, try to clean up
      if (ruleFilePath) {
        try {
          await fs.unlink(ruleFilePath);
          await modSecRepository.deleteModSecRule(rule.id);
        } catch (cleanupError) {
          logger.error('Failed to cleanup after error:', cleanupError);
        }
      }
      throw new Error(`Failed to create custom rule: ${error.message}`);
    }

    logger.info(`Custom ModSecurity rule added: ${rule.name}`, {
      ruleId: rule.id,
    });

    return rule;
  }

  async updateModSecRule(id: string, dto: UpdateModSecRuleDto): Promise<ModSecRule> {
    const rule = await modSecRepository.findModSecRuleById(id);
    if (!rule) {
      throw new Error('ModSecurity rule not found');
    }

    // Validate rule IDs for duplicates if content is being updated
    if (dto.ruleContent !== undefined) {
      const ruleIdValidation = await this.validateRuleIds(dto.ruleContent, id);
      if (!ruleIdValidation.valid) {
        throw new Error(`Rule ID(s) already exist: ${ruleIdValidation.duplicateIds.join(', ')}. Please use unique rule IDs.`);
      }
    }

    // Store original state for rollback
    const originalRule = { ...rule };
    const updatedRule = await modSecRepository.updateModSecRule(id, dto);

    // Handle file updates with proper naming
    const enabledFileName = `custom_${rule.id}.conf`;
    const disabledFileName = `custom_${rule.id}.conf.disabled`;
    const enabledFilePath = path.join(MODSEC_CUSTOM_RULES_PATH, enabledFileName);
    const disabledFilePath = path.join(MODSEC_CUSTOM_RULES_PATH, disabledFileName);

    let backupFilePath: string | null = null;
    let currentFilePath: string | null = null;

    try {
      await fs.mkdir(MODSEC_CUSTOM_RULES_PATH, { recursive: true });

      // Determine which file currently exists
      try {
        await fs.access(enabledFilePath);
        currentFilePath = enabledFilePath;
      } catch {
        try {
          await fs.access(disabledFilePath);
          currentFilePath = disabledFilePath;
        } catch {
          currentFilePath = null;
        }
      }

      // Create backup if file exists
      if (currentFilePath) {
        backupFilePath = `${currentFilePath}.backup`;
        await fs.copyFile(currentFilePath, backupFilePath);
      }

      // Update content if provided
      if (dto.ruleContent !== undefined) {
        const targetFilePath = updatedRule.enabled ? enabledFilePath : disabledFilePath;
        
        // Write new content to target file
        await fs.writeFile(targetFilePath, dto.ruleContent, 'utf-8');
        logger.info(`Custom ModSecurity rule file updated: ${targetFilePath}`);

        // Remove old file if it has different name
        if (currentFilePath && currentFilePath !== targetFilePath) {
          try {
            await fs.unlink(currentFilePath);
            logger.info(`Removed old rule file: ${currentFilePath}`);
          } catch (error) {
            logger.warn(`Could not remove old file: ${currentFilePath}`);
          }
        }
      } else if (dto.enabled !== undefined && currentFilePath) {
        // Only enabled status changed, rename file
        const targetFilePath = updatedRule.enabled ? enabledFilePath : disabledFilePath;
        if (currentFilePath !== targetFilePath) {
          await fs.rename(currentFilePath, targetFilePath);
          logger.info(`Renamed rule file from ${currentFilePath} to ${targetFilePath}`);
        }
      }

      // Test nginx configuration if rule is enabled
      if (updatedRule.enabled) {
        const configTest = await this.testNginxConfig();
        if (!configTest.valid) {
          // Rollback: restore backup and database entry
          if (backupFilePath && currentFilePath) {
            try {
              await fs.copyFile(backupFilePath, currentFilePath);
              await modSecRepository.updateModSecRule(id, {
                name: originalRule.name,
                category: originalRule.category,
                ruleContent: originalRule.ruleContent,
                description: originalRule.description,
                enabled: originalRule.enabled,
              });
            } catch (rollbackError) {
              logger.error('Failed to rollback after nginx config test failure:', rollbackError);
            }
          }
          throw new Error(`Nginx configuration test failed: ${configTest.error}`);
        }

        // Reload nginx if config is valid
        const reloadResult = await this.autoReloadNginx(false);
        if (!reloadResult.success) {
          // Rollback: restore backup and database entry
          if (backupFilePath && currentFilePath) {
            try {
              await fs.copyFile(backupFilePath, currentFilePath);
              await modSecRepository.updateModSecRule(id, {
                name: originalRule.name,
                category: originalRule.category,
                ruleContent: originalRule.ruleContent,
                description: originalRule.description,
                enabled: originalRule.enabled,
              });
            } catch (rollbackError) {
              logger.error('Failed to rollback after nginx reload failure:', rollbackError);
            }
          }
          throw new Error(`Nginx reload failed: ${reloadResult.message}`);
        }
      }

      // Clean up backup file
      if (backupFilePath) {
        try {
          await fs.unlink(backupFilePath);
        } catch (error) {
          logger.warn(`Could not remove backup file: ${backupFilePath}`);
        }
      }
    } catch (error: any) {
      logger.error('Failed to update rule file:', error);
      
      // Clean up backup file on error
      if (backupFilePath) {
        try {
          await fs.unlink(backupFilePath);
        } catch (cleanupError) {
          logger.warn(`Could not remove backup file: ${backupFilePath}`);
        }
      }

      // If it's our validation error, rethrow it
      if (error.message.includes('Nginx configuration test failed') || 
          error.message.includes('Nginx reload failed') ||
          error.message.includes('Rule ID(s) already exist')) {
        throw error;
      }
      
      throw new Error(`Failed to update custom rule: ${error.message}`);
    }

    logger.info(`ModSecurity rule updated: ${updatedRule.name}`, {
      ruleId: id,
    });

    return updatedRule;
  }

  async deleteModSecRule(id: string): Promise<void> {
    const rule = await modSecRepository.findModSecRuleById(id);
    if (!rule) {
      throw new Error('ModSecurity rule not found');
    }

    await modSecRepository.deleteModSecRule(id);

    // Delete both enabled and disabled rule files if they exist
    const enabledFileName = `custom_${rule.id}.conf`;
    const disabledFileName = `custom_${rule.id}.conf.disabled`;
    const enabledFilePath = path.join(MODSEC_CUSTOM_RULES_PATH, enabledFileName);
    const disabledFilePath = path.join(MODSEC_CUSTOM_RULES_PATH, disabledFileName);

    let fileDeleted = false;

    // Try to delete enabled file
    try {
      await fs.unlink(enabledFilePath);
      logger.info(`Custom ModSecurity rule file deleted: ${enabledFilePath}`);
      fileDeleted = true;
    } catch (error: any) {
      // File doesn't exist, that's ok
    }

    // Try to delete disabled file
    try {
      await fs.unlink(disabledFilePath);
      logger.info(`Custom ModSecurity rule file deleted: ${disabledFilePath}`);
      fileDeleted = true;
    } catch (error: any) {
      // File doesn't exist, that's ok
    }

    // Auto reload nginx if any file was deleted
    if (fileDeleted) {
      await this.autoReloadNginx(true);
    }

    logger.info(`ModSecurity rule deleted: ${rule.name}`, {
      ruleId: id,
    });
  }

  /**
   * Global ModSecurity settings
   */

  async getGlobalModSecSettings(): Promise<GlobalModSecSettings> {
    const config = await modSecRepository.findGlobalModSecConfig();
    const enabled = config?.enabled ?? true;

    return {
      enabled,
      config: config || null,
    };
  }

  async setGlobalModSec(dto: SetGlobalModSecDto) {
    const { enabled } = dto;

    // Find existing global ModSecurity config
    let config = await modSecRepository.findGlobalModSecConfig();

    if (config) {
      // Update existing config
      config = await modSecRepository.updateGlobalModSecConfig(config.id, enabled);
    } else {
      // Create new config
      config = await modSecRepository.createGlobalModSecConfig(enabled);
    }

    logger.info(`Global ModSecurity ${enabled ? 'enabled' : 'disabled'}`);

    // Auto reload nginx
    await this.autoReloadNginx(true);

    return config;
  }

  /**
   * Reinitialize ModSecurity configuration
   * This will update main.conf with any missing includes
   */
  async reinitializeConfig(): Promise<{ success: boolean; message: string }> {
    const result = await modSecSetupService.reinitializeModSecurityConfig();
    
    if (result.success) {
      // Auto reload nginx after config update
      await this.autoReloadNginx(true);
    }
    
    return result;
  }
}

export const modSecService = new ModSecService();
