import fs from 'fs/promises';
import { exec } from 'child_process';
import { promisify } from 'util';
import logger from '../../../utils/logger';
import { aclRepository } from '../acl.repository';
import { AclRuleEntity, AclNginxResult } from '../acl.types';

const execAsync = promisify(exec);

/**
 * ACL Nginx Service
 * Handles Nginx configuration generation and management for ACL rules
 */
export class AclNginxService {
  private readonly ACL_CONFIG_FILE = '/etc/nginx/conf.d/acl-rules.conf';
  private readonly NGINX_TEST_CMD = 'nginx -t';
  private readonly NGINX_RELOAD_CMD = 'nginx -s reload';

  /**
   * Generate Nginx ACL configuration from database rules
   */
  async generateAclConfig(): Promise<string> {
    try {
      // Get all enabled ACL rules
      const rules = await aclRepository.findEnabled();

      let config = `# ACL Rules - Auto-generated by Nginx Love UI
# Do not edit manually - Changes will be overwritten
# Generated at: ${new Date().toISOString()}
#
# This file is included in all domain vhost configurations
# Rules are processed in order: whitelist first, then blacklist
\n`;

      // Separate rules by field type
      const ipRules = rules.filter(r => r.conditionField === 'ip');
      const userAgentRules = rules.filter(r => r.conditionField === 'user_agent');
      const geoipRules = rules.filter(r => r.conditionField === 'geoip');
      const urlRules = rules.filter(r => r.conditionField === 'url');
      const methodRules = rules.filter(r => r.conditionField === 'method');
      const headerRules = rules.filter(r => r.conditionField === 'header');

      // Generate IP-based rules (most common)
      if (ipRules.length > 0) {
        config += `\n# ===== IP-Based Access Control =====\n\n`;

        const whitelists = ipRules.filter(r => r.type === 'whitelist');
        const blacklists = ipRules.filter(r => r.type === 'blacklist');

        // Whitelists first (allow)
        if (whitelists.length > 0) {
          config += `# IP Whitelists (Allow)\n`;
          for (const rule of whitelists) {
            config += `# ${rule.name}\n`;
            config += this.generateIpDirective(rule);
          }
        }

        // Blacklists (deny)
        if (blacklists.length > 0) {
          config += `\n# IP Blacklists (Deny)\n`;
          for (const rule of blacklists) {
            config += `# ${rule.name}\n`;
            config += this.generateIpDirective(rule);
          }
        }

        // Only add "deny all" if there are ONLY whitelists and NO blacklists
        // If there are blacklists, they should be specific denies without blocking everything else
        if (whitelists.length > 0 && blacklists.length === 0) {
          config += `\n# Deny all IPs not explicitly whitelisted\n`;
          config += `deny all;\n`;
        }
      }

      // Generate User-Agent rules
      if (userAgentRules.length > 0) {
        config += `\n# ===== User-Agent Based Access Control =====\n`;
        config += `\nif ($http_user_agent ~* "BLOCKED_AGENTS") {\n`;
        config += `    return 403 "Access Denied - Blocked User Agent";\n`;
        config += `}\n\n`;

        config += `# User-Agent Rules:\n`;
        for (const rule of userAgentRules) {
          if (rule.type === 'blacklist') {
            config += `# ${rule.name}\n`;
            config += `if ($http_user_agent ~* "${rule.conditionValue}") {\n`;
            if (rule.action === 'deny') {
              config += `    return 403 "Access Denied";\n`;
            } else if (rule.action === 'challenge') {
              config += `    # Challenge - implement CAPTCHA or rate limiting here\n`;
              config += `    return 429 "Too Many Requests - Please try again";\n`;
            }
            config += `}\n\n`;
          }
        }
      }

      // Generate URL-based rules
      if (urlRules.length > 0) {
        config += `\n# ===== URL-Based Access Control =====\n\n`;
        for (const rule of urlRules) {
          config += `# ${rule.name}\n`;
          const operator = rule.conditionOperator === 'regex' ? '~' :
                          rule.conditionOperator === 'equals' ? '=' : '~*';
          config += `location ${operator} "${rule.conditionValue}" {\n`;
          if (rule.action === 'deny') {
            config += `    deny all;\n`;
          } else if (rule.action === 'allow') {
            config += `    allow all;\n`;
          }
          config += `}\n\n`;
        }
      }

      // Generate Method-based rules
      if (methodRules.length > 0) {
        config += `\n# ===== HTTP Method Access Control =====\n\n`;
        for (const rule of methodRules) {
          config += `# ${rule.name}\n`;
          if (rule.type === 'blacklist' && rule.action === 'deny') {
            config += `if ($request_method = "${rule.conditionValue}") {\n`;
            config += `    return 405 "Method Not Allowed";\n`;
            config += `}\n\n`;
          }
        }
      }

      config += `\n# End of ACL Rules\n`;

      return config;
    } catch (error) {
      logger.error('Failed to generate ACL config:', error);
      throw error;
    }
  }

  /**
   * Generate IP directive based on rule
   */
  private generateIpDirective(rule: AclRuleEntity): string {
    let directive = '';

    const action = rule.type === 'whitelist' ? 'allow' : 'deny';

    if (rule.conditionOperator === 'equals') {
      // Exact IP match
      directive = `${action} ${rule.conditionValue};\n`;
    } else if (rule.conditionOperator === 'regex') {
      // Regex pattern - use geo module or map
      directive = `# Regex pattern: ${rule.conditionValue}\n`;
      directive += `# Note: Nginx IP matching doesn't support regex directly\n`;
      directive += `# Consider using CIDR notation or specific IPs\n`;
    } else if (rule.conditionOperator === 'contains') {
      // Network/CIDR
      directive = `${action} ${rule.conditionValue};\n`;
    }

    return directive;
  }

  /**
   * Write ACL config to Nginx configuration file
   */
  async writeAclConfig(config: string): Promise<void> {
    try {
      await fs.writeFile(this.ACL_CONFIG_FILE, config, 'utf8');
      logger.info(`ACL config written to ${this.ACL_CONFIG_FILE}`);
    } catch (error) {
      logger.error('Failed to write ACL config:', error);
      throw error;
    }
  }

  /**
   * Test Nginx configuration
   */
  async testNginxConfig(): Promise<boolean> {
    try {
      const { stdout, stderr } = await execAsync(this.NGINX_TEST_CMD);
      logger.info('Nginx config test passed:', stdout);
      return true;
    } catch (error: any) {
      logger.error('Nginx config test failed:', error.stderr || error.message);
      return false;
    }
  }

  /**
   * Reload Nginx to apply new configuration
   */
  async reloadNginx(): Promise<void> {
    try {
      const { stdout } = await execAsync(this.NGINX_RELOAD_CMD);
      logger.info('Nginx reloaded successfully:', stdout);
    } catch (error: any) {
      logger.error('Failed to reload Nginx:', error);
      throw error;
    }
  }

  /**
   * Apply ACL rules to Nginx
   * Main function to generate config, test, and reload
   */
  async applyAclRules(): Promise<AclNginxResult> {
    try {
      logger.info('Starting ACL rules application...');

      // 1. Generate config from database
      logger.info('Generating ACL configuration...');
      const config = await this.generateAclConfig();

      // 2. Write to file
      logger.info('Writing ACL config to Nginx...');
      await this.writeAclConfig(config);

      // 3. Test Nginx config
      logger.info('Testing Nginx configuration...');
      const testPassed = await this.testNginxConfig();

      if (!testPassed) {
        return {
          success: false,
          message: 'Nginx configuration test failed. Rules not applied.'
        };
      }

      // 4. Reload Nginx
      logger.info('Reloading Nginx...');
      await this.reloadNginx();

      logger.info('ACL rules applied successfully');

      return {
        success: true,
        message: 'ACL rules applied successfully'
      };
    } catch (error: any) {
      logger.error('Failed to apply ACL rules:', error);
      return {
        success: false,
        message: `Failed to apply ACL rules: ${error.message}`
      };
    }
  }

  /**
   * Initialize ACL config file if not exists
   */
  async initializeAclConfig(): Promise<void> {
    try {
      try {
        await fs.access(this.ACL_CONFIG_FILE);
        logger.info('ACL config file already exists');
      } catch {
        // File doesn't exist, create it
        const emptyConfig = `# ACL Rules - Nginx Love UI
# This file will be populated with ACL rules
\n# No rules configured yet\n`;

        await this.writeAclConfig(emptyConfig);
        logger.info('ACL config file initialized');
      }
    } catch (error) {
      logger.error('Failed to initialize ACL config:', error);
    }
  }
}

// Export singleton instance
export const aclNginxService = new AclNginxService();
