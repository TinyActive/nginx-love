import * as fs from 'fs/promises';
import * as path from 'path';
import { exec } from 'child_process';
import { promisify } from 'util';
import logger from '../../utils/logger';
import { modSecRepository } from './modsec.repository';
import { crsRulesService } from './services/crs-rules.service';
import { AddCustomRuleDto, UpdateModSecRuleDto, ToggleCRSRuleDto, SetGlobalModSecDto } from './dto';
import { CRSRule, ModSecRule, ModSecRuleWithDomain, GlobalModSecSettings, NginxReloadResult } from './modsec.types';

const execAsync = promisify(exec);

const MODSEC_CUSTOM_RULES_PATH = '/etc/nginx/modsec/custom_rules';
const MODSEC_CRS_DISABLE_FILE = '/etc/nginx/modsec/crs_disabled.conf';

/**
 * ModSecurity service
 * Handles all business logic for ModSecurity rules management
 */
export class ModSecService {
  /**
   * Extract actual rule IDs from CRS rule file
   */
  private async extractRuleIdsFromCRSFile(ruleFile: string): Promise<number[]> {
    try {
      const crsFilePath = path.join('/etc/nginx/modsec/coreruleset/rules', ruleFile);
      const content = await fs.readFile(crsFilePath, 'utf-8');

      // Extract all "id:XXXXX" patterns
      const idMatches = content.matchAll(/id:(\d+)/g);
      const ids = new Set<number>();

      for (const match of idMatches) {
        ids.add(parseInt(match[1]));
      }

      return Array.from(ids).sort((a, b) => a - b);
    } catch (error: any) {
      logger.warn(`Failed to extract rule IDs from ${ruleFile}: ${error.message}`);
      return [];
    }
  }

  /**
   * Regenerate CRS disable configuration file from database
   */
  private async regenerateCRSDisableConfig(domainId?: string): Promise<void> {
    try {
      // Get all disabled CRS rules from database
      const disabledRules = await modSecRepository.findCRSRules(domainId);
      const disabledOnly = disabledRules.filter(rule => !rule.enabled);

      // Build disable content
      let disableContent = '# CRS Disabled Rules\n';
      disableContent += '# Auto-generated by Nginx Love UI - DO NOT EDIT MANUALLY\n';
      disableContent += `# Generated at: ${new Date().toISOString()}\n\n`;

      if (disabledOnly.length === 0) {
        disableContent += '# No disabled rules\n';
      } else {
        for (const rule of disabledOnly) {
          const crsRule = crsRulesService.getRuleByFile(rule.ruleFile);
          if (!crsRule) continue;

          disableContent += `# Disable: ${crsRule.name} (${crsRule.category})\n`;
          disableContent += `# File: ${crsRule.ruleFile}\n`;

          // Extract actual rule IDs from CRS file
          const ruleIds = await this.extractRuleIdsFromCRSFile(crsRule.ruleFile);

          if (ruleIds.length === 0) {
            disableContent += `# Warning: No rule IDs found in ${crsRule.ruleFile}\n`;
          } else {
            disableContent += `# Found ${ruleIds.length} rules to disable\n`;

            // Remove rules by actual IDs
            for (const id of ruleIds) {
              disableContent += `SecRuleRemoveById ${id}\n`;
            }
          }
          disableContent += '\n';
        }
      }

      // Write to single disable file
      await fs.writeFile(MODSEC_CRS_DISABLE_FILE, disableContent, 'utf-8');
      logger.info(`Regenerated CRS disable config: ${disabledOnly.length} rule file(s) disabled`);
    } catch (error) {
      logger.error('Failed to regenerate CRS disable config:', error);
      throw error;
    }
  }

  /**
   * Auto reload nginx with smart retry logic
   */
  private async autoReloadNginx(silent: boolean = false): Promise<NginxReloadResult> {
    try {
      // Test nginx configuration first
      try {
        await execAsync('nginx -t');
      } catch (error: any) {
        logger.error('Nginx configuration test failed:', error.stderr);
        if (!silent) throw new Error(`Nginx config test failed: ${error.stderr}`);
        return { success: false, message: `Nginx config test failed: ${error.stderr}` };
      }

      // Try graceful reload first
      try {
        logger.info('Auto-reloading nginx (graceful)...');
        await execAsync('nginx -s reload');

        // Wait for reload to take effect
        await new Promise(resolve => setTimeout(resolve, 2000));

        // Verify nginx is active
        const { stdout } = await execAsync("pgrep nginx > /dev/null && echo 'active' || echo 'inactive'");
        if (stdout.trim() === 'active') {
          logger.info('Nginx auto-reloaded successfully');
          return { success: true };
        }
      } catch (error: any) {
        logger.warn('Graceful reload failed, trying restart...', error.message);
      }

      // Fallback to restart
      logger.info('Auto-restarting nginx...');
      await execAsync('nginx -s stop || true && rm -f /var/run/nginx.pid && nginx');

      // Wait for restart
      await new Promise(resolve => setTimeout(resolve, 1000));

      // Verify nginx started
      const { stdout } = await execAsync("pgrep nginx > /dev/null && echo 'active' || echo 'inactive'");
      if (stdout.trim() !== 'active') {
        throw new Error('Nginx not active after restart');
      }

      logger.info('Nginx auto-restarted successfully');
      return { success: true };
    } catch (error: any) {
      logger.error('Auto reload nginx failed:', error);
      if (!silent) throw error;
      return { success: false, message: error.message };
    }
  }

  /**
   * CRS Rules operations
   */

  async getCRSRules(domainId?: string): Promise<CRSRule[]> {
    // Get enabled status from database
    const dbRules = await modSecRepository.findCRSRules(domainId);

    // Map CRS_RULES with DB status
    const allCRSRules = crsRulesService.getAllRules();
    const rules = allCRSRules.map(crsRule => {
      const dbRule = dbRules.find(r => r.ruleFile === crsRule.ruleFile);
      return {
        id: dbRule?.id,
        ruleFile: crsRule.ruleFile,
        name: crsRule.name,
        category: crsRule.category,
        description: crsRule.description,
        enabled: dbRule?.enabled ?? true, // Default enabled
        paranoia: crsRule.paranoia || 1,
        createdAt: dbRule?.createdAt,
        updatedAt: dbRule?.updatedAt,
      };
    });

    return rules;
  }

  async toggleCRSRule(ruleFile: string, dto: ToggleCRSRuleDto): Promise<CRSRule> {
    const { domainId } = dto;

    // Check if rule file exists in CRS_RULES
    const crsRule = crsRulesService.getRuleByFile(ruleFile);
    if (!crsRule) {
      throw new Error('CRS rule not found');
    }

    // Get current status or create new
    const existingRule = await modSecRepository.findCRSRuleByFile(ruleFile, domainId);

    let updatedRule;
    if (existingRule) {
      // Toggle existing
      updatedRule = await modSecRepository.updateCRSRule(existingRule.id, !existingRule.enabled);
    } else {
      // Create new (disabled by default since we're toggling)
      updatedRule = await modSecRepository.createCRSRule({
        ruleFile: crsRule.ruleFile,
        name: crsRule.name,
        category: crsRule.category,
        description: crsRule.description,
        enabled: false,
        paranoia: crsRule.paranoia || 1,
        domainId: domainId || null,
      });
    }

    logger.info(`CRS rule ${crsRule.name} ${updatedRule.enabled ? 'enabled' : 'disabled'}`, {
      ruleFile,
    });

    // Regenerate CRS disable configuration file
    await this.regenerateCRSDisableConfig(domainId);

    // Auto reload nginx
    await this.autoReloadNginx(true);

    return {
      id: updatedRule.id ?? undefined,
      ruleFile: updatedRule.ruleFile,
      name: updatedRule.name,
      category: updatedRule.category,
      description: updatedRule.description,
      enabled: updatedRule.enabled,
      paranoia: updatedRule.paranoia,
      createdAt: updatedRule.createdAt,
      updatedAt: updatedRule.updatedAt,
    };
  }

  /**
   * Custom ModSec Rules operations
   */

  async getModSecRules(domainId?: string): Promise<ModSecRule[]> {
    return modSecRepository.findModSecRules(domainId);
  }

  async getModSecRule(id: string): Promise<ModSecRuleWithDomain> {
    const rule = await modSecRepository.findModSecRuleById(id);
    if (!rule) {
      throw new Error('ModSecurity rule not found');
    }
    return rule;
  }

  async toggleModSecRule(id: string): Promise<ModSecRule> {
    const rule = await modSecRepository.findModSecRuleById(id);
    if (!rule) {
      throw new Error('ModSecurity rule not found');
    }

    const updatedRule = await modSecRepository.toggleModSecRule(id, !rule.enabled);

    logger.info(`ModSecurity rule ${updatedRule.name} ${updatedRule.enabled ? 'enabled' : 'disabled'}`, {
      ruleId: id,
    });

    // Auto reload nginx
    await this.autoReloadNginx(true);

    return updatedRule;
  }

  async addCustomRule(dto: AddCustomRuleDto): Promise<ModSecRule> {
    // Validate domain if specified
    if (dto.domainId) {
      const domain = await modSecRepository.findDomainById(dto.domainId);
      if (!domain) {
        throw new Error('Domain not found');
      }
    }

    // Create rule in database
    const rule = await modSecRepository.createModSecRule(dto);

    // Write rule to file if enabled
    if (rule.enabled) {
      try {
        // Ensure custom rules directory exists
        await fs.mkdir(MODSEC_CUSTOM_RULES_PATH, { recursive: true });

        const ruleFileName = `custom_${rule.id}.conf`;
        const ruleFilePath = path.join(MODSEC_CUSTOM_RULES_PATH, ruleFileName);

        await fs.writeFile(ruleFilePath, dto.ruleContent, 'utf-8');
        logger.info(`Custom ModSecurity rule file created: ${ruleFilePath}`);

        // Auto reload nginx
        await this.autoReloadNginx(true);
      } catch (error: any) {
        logger.error('Failed to write custom rule file:', error);
        // Continue even if file write fails
      }
    }

    logger.info(`Custom ModSecurity rule added: ${rule.name}`, {
      ruleId: rule.id,
    });

    return rule;
  }

  async updateModSecRule(id: string, dto: UpdateModSecRuleDto): Promise<ModSecRule> {
    const rule = await modSecRepository.findModSecRuleById(id);
    if (!rule) {
      throw new Error('ModSecurity rule not found');
    }

    const updatedRule = await modSecRepository.updateModSecRule(id, dto);

    // Update rule file if exists
    const ruleFileName = `custom_${rule.id}.conf`;
    const ruleFilePath = path.join(MODSEC_CUSTOM_RULES_PATH, ruleFileName);

    try {
      await fs.access(ruleFilePath);

      if (updatedRule.enabled && dto.ruleContent) {
        await fs.writeFile(ruleFilePath, dto.ruleContent, 'utf-8');
        logger.info(`Custom ModSecurity rule file updated: ${ruleFilePath}`);
      } else if (!updatedRule.enabled) {
        await fs.unlink(ruleFilePath);
        logger.info(`Custom ModSecurity rule file removed: ${ruleFilePath}`);
      }

      // Auto reload nginx
      await this.autoReloadNginx(true);
    } catch (error: any) {
      // File doesn't exist or error accessing it
      if (updatedRule.enabled && dto.ruleContent) {
        await fs.mkdir(MODSEC_CUSTOM_RULES_PATH, { recursive: true });
        await fs.writeFile(ruleFilePath, dto.ruleContent, 'utf-8');
        await this.autoReloadNginx(true);
      }
    }

    logger.info(`ModSecurity rule updated: ${updatedRule.name}`, {
      ruleId: id,
    });

    return updatedRule;
  }

  async deleteModSecRule(id: string): Promise<void> {
    const rule = await modSecRepository.findModSecRuleById(id);
    if (!rule) {
      throw new Error('ModSecurity rule not found');
    }

    await modSecRepository.deleteModSecRule(id);

    // Delete rule file if exists
    const ruleFileName = `custom_${rule.id}.conf`;
    const ruleFilePath = path.join(MODSEC_CUSTOM_RULES_PATH, ruleFileName);

    try {
      await fs.unlink(ruleFilePath);
      logger.info(`Custom ModSecurity rule file deleted: ${ruleFilePath}`);

      // Auto reload nginx
      await this.autoReloadNginx(true);
    } catch (error: any) {
      // File doesn't exist, continue
    }

    logger.info(`ModSecurity rule deleted: ${rule.name}`, {
      ruleId: id,
    });
  }

  /**
   * Global ModSecurity settings
   */

  async getGlobalModSecSettings(): Promise<GlobalModSecSettings> {
    const config = await modSecRepository.findGlobalModSecConfig();
    const enabled = config?.enabled ?? true;

    return {
      enabled,
      config: config || null,
    };
  }

  async setGlobalModSec(dto: SetGlobalModSecDto) {
    const { enabled } = dto;

    // Find existing global ModSecurity config
    let config = await modSecRepository.findGlobalModSecConfig();

    if (config) {
      // Update existing config
      config = await modSecRepository.updateGlobalModSecConfig(config.id, enabled);
    } else {
      // Create new config
      config = await modSecRepository.createGlobalModSecConfig(enabled);
    }

    logger.info(`Global ModSecurity ${enabled ? 'enabled' : 'disabled'}`);

    // Auto reload nginx
    await this.autoReloadNginx(true);

    return config;
  }
}

export const modSecService = new ModSecService();
